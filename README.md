# Algorithm with python

알고리즘 유형에 따라 폴더를 분류 했습니다

각 폴더별
1. 백준 문제
2. 책 '이것이 취업을 위한 코딩 테스트다' 수록 예제 및 기출 문제
<br>

# 목차
<details>
<summary>백준(BOG)</summary>
<div markdown="1">

  - 11-완전탐색(brute_force)
  - 12-정렬(sort)
  - 15-동적계획법1(dynamic_programing)
  - 16-그리디알고리즘(greedy)
  - 17-정수론&조합론
  - 21-이분탐색(binary_search)
  - 24-DFS&BFS
  - 33-동적계획법3
  - extra

  </div>
</details>

<details>
<summary>이것이취업을위한코딩테스트다</summary> <br>
<div>
  
<details>
<summary>part2-예제</summary>
<div markdown="1">

<details>
<summary>greedy</summary>
<div markdown="1">

현재 상황에서 지금 당장 좋은 것만 고르는 방법
  
그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로, 
문제에서 '가장 큰 순서대로' 또는 '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시한다.
>  위 예시같은 큰/작은 순서대로라는 기준은 정렬 알고리즘을 사용하면 만족시킬 수 있어, 정렬 알고리즘 문제와 자주 짝을 이루어 출제됨
  
</div>
</details>  
  
- 1-greedy
- 2-implementation
- 3-DFS&BFS
- 4-sort
- 5-binary_search
- 6-dynamic_programing
- 7-shortest_route
- 8-graph

</div>
</details>

<details>
<summary>part3-기출</summary>
<div markdown="1">

- 1-greedy
- 2-implementation
- 3-DFS&BFS
- 4-sort
- 5-binary_search
- 6-dynamic_programing
- 7-shortest_route
- 8-graph
- 9-2020_상반기_삼성전자

</div>
</details>
    
</div>
</details>

<details>
<summary>프로그래머스(추가예정)</summary>
<div markdown="1">

</div>
</details>
<br>

# 복잡도
- 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수
- 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양

<details>
<summary>시간 복잡도</summary>
<div markdown="1">

제한시간이 1초일 때
|N 의 범위|권장 시간 복잡도|
|---|---|
|500|O(N³)|
|2,000|O(N²)|
|100,000|O(NlogN)|
|10,000,000|O(N)|
  
</div>
</details>

<details>
<summary>공간 복잡도</summary>
<div markdown="1">

일반적으로 코딩 테스트에서 제시되는 메모리 사용량을 128~512MB
- 데이터 개수가 1,000만 단위가 넘어가지 않도록 알고리즘을 설계해야한다.
> 만약 그 이상이라면, 알고리즘 설계가 잘못되었을 확률이 높다.

int 자료형 데이터의 개수에 따른 메모리 사용량
|데이터 개수|메모리 사용량|
|---|---|
|1,000|약 4KB|
|1,000,000|약 4MB|
|10,000,000|약 40MB|

Pypy3는 Pyhon3의 문법을 그대로 지원하면서, 대부분 실행속도가 더 빠르다.
즉, 같은 코드라도 Pypy3로 제출했을 때 실행속도를 더 줄일 수 있다.

만약, 반복문이 많이 필요한 알고리즘이고, 코딩테스트에서 환경에서 Pypy3를 지원한다면 이를 활용하자. 
> 삼성전자 공채의 경우 응시자가 python3로 제출한 경우 pypy3로 채점한다.
  
</div>
</details>
<br>

# 알고리즘 
<details>
<summary>greedy</summary>
<div markdown="1">

그리디 알고리즘은 '현재 상황에서 지금 당장 좋은 것만 고르는 방법'을 의미한다.

기준에 따라 좋은 것을 선택하는 알고리즘이므로, 문제에서 기준에 대한 힌트를 제시한다.
> '가장 큰 순서대로' or '가장 작은 순서대로'와 같은 크기와 순서에 대한 기준이 자주 제시되는데,
> '정렬 알고리즘'을 사용하면 해당 기준을 만족 시킬 수 있어
> '정렬 알고리즘'과 자주 짝을 이루어 출제 된다.
  
</div>
</details>
 
<details>
<summary>implementation</summary>
<div markdown="1">

- bruteforce(완전 탐색) : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
- simulation(시뮬레이션) : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행
  
</div>
</details>  
  
<details>
<summary>DFS&BFS</summary>
<div markdown="1">

- depth_first_search(깊이 우선 탐색)
    - 깊이 우선 탐색 알고리즘이며 그래프를 탐색하는 알고리즘이다. 최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작하며 스택 자료구조를 이용한다.
    - 시간 복잡도 : O(N)
- breadth_first_search(너비 우선 탐색)
    - 가까운 노드부터 탐색하는 알고리즘이다. 선입선출 방식의 큐를 이용한다.
    - 시간 복잡도 : O(N), 일반적인 경우 실제 수행 시간은 DFS 보다 좋은 편이다.

> 인접 행렬 vs 2차원 인접 리스트   
> 인점 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
> ```
> # 인접 행렬 예시
> graph = [[] for _ in range(3)]
> 
> # 노드 0에 연결된 노드 정보 : (노드, 거리)
> graph[0].append((1, 7))
> graph[0].append((2, 5))
> 
> # 노드 1에 연결된 노드 정보 : (노드, 거리)
> graph[1].append((0, 7))
> ```
>
> 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식
> ```
> # 인접 리스트 예시
> 
> INF = 987654321  # 10e9, 연결되어있지 않음을 무한 비용으로 표현
> 
> graph = [
>       [0, 7, 5],
>       [7, 0, INF],
>       [5, INF, 0]
>   ]
> ```
> 
> 인접 행렬 방식은 모든 관계를 저장하므로, 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.
>
> 인접 리스트 방식은 특정 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 
>
> 따라서, 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 
> 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공강의 낭비가 적다.

</div>
</details>  

<details>
<summary>sort</summary>
<div markdown="1">

- selection_sort(선택 정렬) 
    - 시간 복잡도 : O(N²)
    - 공간 복잡도 : O(N)
    - 매번 가장 작은 것을 선택
- insertion_sort(삽입 정렬)
    - O(N²), 최선의 경우 O(N)까지 가능 > 정렬이 거의 되어 있는 경우
    - 공간 복잡도 : O(N)
    - 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입
    - 필요할 때만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 다른 알고리즘 보다 훨씬 빠르고, 효율적
- quick_sort(퀵 정렬) : 
    - 시간 복잡도 : 최악의 경우 O(N²), 평균 O(NlogN)
    - 공간 복잡도 : O(N)
    - 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.
    - 데이터가 무작위로 입력되는 경우 빠르게 동작할 확률이 높지만, 이미 데이터가 정렬되어 있는 경우 매우 느리게 동작한다.
- count_sort(계수 정렬) : 
    - 시간 복잡도 : O(N + K), (K : 데이터 중 최대값의 크기)    
    - 공간 복잡도 : O(N + K)
    - 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 잇을 때
    - 모든 범위를 담을 수 있는 크기의 리스트를 선언 후 각 크기에 따른 갯수를 저장
    - 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.
- radix_sort(기수정렬)
- heap_sort(힙 정렬)
- 병합 정렬 : 최악의 경우 O(NlogN)

</div>
</details>  

<details>
<summary>binary_search</summary>
<div markdown="1">

- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 과정이다.
- 한번 확인할 때마다 확인하는 원소가 평균적으로 절반씩 줄어든다.
- 시간복잡도 : O(logN)
- 탐색 범위, 처리할 데이터가 2000만 이상이라면 O(logN) 의 속도를 내는 알고리즘이 필요하다.

> 무엇을 이분탐색 할것인가?   
> 문제에서 무엇을 이분탐색할지 잘 모르겠다면, 
> 탐색을 통해 데이터에 있는 값을 찾는 것이 목표가 아니라,
> 내가 찾고자 하는 값이 탐색을 했을 때, 정답인가 아닌가를 체크해야하는 문제일 확률이 높다.
> 문제에서 요구하는 답을 기준(중간값)으로 탐색을 하면서 그 값이 정답인지 아닌지 확인한다.

</div>
</details>  

<details>
<summary>dynamic_programming</summary>
<div markdown="1">

큰 문제를 작게 나누고, 같은 문제는 한 번씩만 풀어(메모이제이션) 문제를 효율적으로 해결하는 알고리즘 기법

- 사용 조건
    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

- 구현 방법
    - 탑다운 : 큰 문제를 해결하기 위해 작은 문제를 호출 (재귀함수)
    - 보텀업 : 작은 문제부터 차근차근 답 도출 (반복문)
> 탑다운 vs 보텀업   
> 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문에,
> 탑다운 보다는 보텀업 방식을 권장한다.

> 메모이제이션   
> 한 번 구한 결과를 메모리 공간에 메모해두고 
> 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법이다.
>
> 한 번 구한 정보를 리스트에 저장하고, 
> 이미 구한 정답을 그대로 리스트에서 가져오면 된다.
>
> 일반적으로 배열, 리스트에 저장하지만,
> 수열처럼 연속적이지 않고, 일부의 작은 문제에 대한 해답만 필요한 경우
> '사전(dict)' 자료형을 사용하는 것이 더 효과적이다.

> 분할정복 vs 다이나믹 프로그래밍   
> 다이나믹 프로그래밍
> - 문제들이 서로 영향을 미치고 있다.
> - 한 번 해결했던 문제를 다시 해결해야하는 상황이 발생한다.

특정 문제에 대해서 완전 탐색이 필요하지만, 완전 탐색 알고리즘으로 접근했을 때,
시간이 매우 오래 걸리는 경우 다이나믹 프로그래밍을 생각해볼 수 있다.

이때, 특히 해당 문제를 해결하기 위해 해결해야하는 부분 문제들의 반복이 있다면
다이나믹 프로그래밍을 활용해야할 확률이 높다.

</div>
</details>  

<details>
<summary>shortest_route</summary>
<div markdown="1">

가장 짧은 경로를 찾는 알고리즘

> 다이나믹 프로그래밍과 그리디 알고리즘의 한 유형으로 볼 수 있다.

- dijkstra(다익스트라) : 
    - V : 노드, E : 간선(에지)
    - 매번 가장 비용이 적은 노드를 선택하여 임의의 과정을 반복한다.
    - 각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원 리스트(최단 거리 테이블)에 저장하며 리스트를 계속 갱신
    - 원리
        1. 출발 노드를 설정한다.
        2. 최단 거리 테이블을 초기화 한다
        3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
        4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
        5. 위 과정에서 3,4 번을 반복한다.
     
    - 구현방법에 따른 시간 복잡도
        - 간단한 방법 : O(V²) - 
        O(V)번에 걸쳐 최단 거리가 가장 짧은 노드를 매번 선형 탐색
    
        - 개선된 방법 : O(ElogV) - 
        최단 거리가 가장 짧은 노드를 선형적으로 찾는 것이 아니라 
        힙 자료구조(최소 힙, 우선순위 큐)를 활용하여 탐색, logV 의 시간이 걸린다.

- floyd_warshall(프로이드 워셜)
    - N : 노드수
    - 모든 노드에 대해서 현재 노드를 거쳐가는 모든 경로를 고려하므로 O(N),
    노드 N_k를 지나면서 N₁에서 N₂로 가는 모든 (N₁, N₂) 쌍에 대해서 최단거리를 갱신하므로 O(N²)
    → ∴ O(N³)
    - 점화식 : D₁₂ = min(D₁₂, D₁_k + D_k₂)
    - 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우 사용가능하다.

</div>
</details>  

<details>
<summary>graph</summary>
<div markdown="1">

DFS&BFS, 다익스트라, 플로이드 워셜을 제외하고, 
코딩 테스트를 위해 필요한 여러가지 그래프 알고리즘에 대해서 정리한다.

>그래프의 구현 방법은
> - 인접 행렬
> - 인접 리스트
>
> 2가지 방식이 있다.   
> 📣 DFS&BFS 참고

#### disjoint_sets(서로소 집합)
- 서로소 집합 : 공통 원소가 없는 두 집합
- 서로소 집합 자료구조 : 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
    - union 연산 : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산이다.
    - find 연산 : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.
    - 시간 복잡도 : 노드의 개수가 V개이고, 
    최대 V-1 개의 union 연산과 M개의 find 연산이 가능할 때, 
    경로 압축 방법을 적용한 시간복잡도는 O(V + Mlog₂V)
    - 알고리즘
        1. union 연산을 확인하여, 서로 연결된 두 노드 A, B 를 확인한다.
            1. A 와 B의 루트 노드 A', B'를 각각 찾는다.
            2. A'를 B' 의 부모 노드로 설정한다.
        2. 모든 union 연산을 처리할 때까지 1번 과정을 반복한다.
- 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다.
    1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
        1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산 수행한다.
        2. 루트 노드가 서로 같다면 사이클이 발생한 것이다.
    2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.
    
> 방향 그래프에서의 사이클 판별은 DFS 를 이용하여 판별 가능
    
#### kruskal(크루스칼)
최소 신장 트리를 찾기 위한 알고리즘

- 그리디 알고리즘 분류
- 알고리즘
    1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.(가장 거리가 짧은 간선부터 차례로 확인)
    2. 간선을 하나씩 확인하며 현재의 간선이 사이클이 발생시키는지 확인한다
        1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
        2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
    3. 모든 간선에 대하여 2번의 과정을 반복한다.
- 시간 복잡도 : O(ElogE) - E 개의 데이터를 정렬했을 때의 시간 복잡도

> 신장 트리   
> 하나의 그래프가 있을 때,
> - 모든 노드를 포함
> - 사이클이 존재하지 않는 부분 그래프
> 
> 위와 같은 조건을 만족하는 트리 구조

노드와 노드끼리 연결할 때, 최소의 비용으로 연결하는 방법에 관련된 문제가 출제된다.
ex) 두 도시에 도로는 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우 최소비용 구하기

#### topology_sort(위상 정렬)
방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
- 알고리즘
    1. 진입차수가 0인 노드를 큐에 넣는다.
    2. 큐가 빌 때까지 다음의 과정을 반복한다.
        1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
        2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.
- 시간 복잡도 : O(V + E) - 
   모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례로 제거하므로
   모든 노드와 간선을 확인한다.

ex) 선수과목을 고려한 학습 순서 설정
  
</div>
</details>  
<br>

# 알고리즘 풀이법
<details>
<summary>세부사항</summary>
<div markdown="1">

1. 문제에 대한 이해를 적는다.
2. 입력 값을 확인한다.
   - 입력 값의 범위를 통해 짜야할 알고리즘의 최대 시간 복잡도를 체크한다. > 필요한 알고리즘에 대한 힌트를 얻을 수 있다.
   - 문제에는 나타나 있지 않는 입력 값에 대한 설명을 체크한다. ex) 입력 숫자 0 은 빈칸을 의미한다. 'end' 가 입력되면 프로그램을 종료한다.
   - 극단적인 입력값 테스트 케이스를 고려한다.
3. 출력 값을 확인한다.
   - 문제에는 나타나 있지 않은 출력 값에 대한 예외처리를 체크한다. ex) 불가능한 경우 -1 을 출력한다.
4. 필요한 변수 생성 및 입력 값 초기화
  
</div>
</details> 

# 추가 정보
백준 단계별 :  https://www.acmicpc.net/step   
blog : https://hayleykimlog.tistory.com
